Lex.cpp 和 Lex.hpp 为lex类，程序的主体部分，main.cpp为对lex类的使用
a.out为上述文件生成的可执行文件(mac-os, 其他平台需重新编译，需支持c++11)
temp.l为写好的lex文件
执行a.out 会根据temp.l生成out.c

temp.c为一段测试的c源代码
out.c编译后生成可执行文件out, 执行 ./out temp.c 会生成temp.c对应的词法分析结果

# 具体步骤，
1. 解析lex文本，获取预设代码(%{%})，自定义输入映射(%!%!)，正规式与对应的方法体(%% %%)
2. 将正规式转换成NFA（这里没有用书上的方法，自己用了三个栈来实现，时间空间复杂度都是O(n), 转换过程在博客里有说明[http://blog.csdn.net/to_be_better/article/details/52721920](http://blog.csdn.net/to_be_better/article/details/52721920)）
3. 将NFA转换成DFA
4. 将DFA进行最小化(这一步不影响大局，暂时未去完善)
5. 根据DFA动态生成词法分析器里自动机部分的代码

# 目前的问题
1. 没有对正规式的正确性进行判断，想在后面用语法分析来解决
2. 上面的第一步等同于对lex文件进行词法分析，因为其实际上是一种自定义语法，所以需要对其完善报错，好方便使用者
3. 优化

---------------------
	temp.l内容注释
	%{
	这里会让用户去写一些预设在词法分析程序里的代码
	和 自定义函数
	%}

	%!
	这里写一些自定义输入的映射
	例如
	letter = isLetter
	isLetter会在上面%{%}区域进行实现，是一个形参为char ch，成功返回值为1否则为0的函数
	%!

	%%
	这里需要去将分析的词法里所有合法的单词用正规式进行表示
	如  c语言的标识符
	({letter}|_)({letter}|_|{digit})*   {
	这里要写的是当解析出该单词之后，要执行的动作
	比如 printf("<$IDm, ->\n");
	}
	%%
